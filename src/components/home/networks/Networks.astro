---
import { getLangFromUrl, useTranslations } from '@/i18n/utils';
import { R2_PUBLIC_URL } from '@/data/r2';
import { getNetworks } from '@/data/networks';
import { type CardType, type SearchableNetwork, type GridItem, imgClass } from './types';
import NetworkCardRectangleBig from './NetworkCardRectangleBig.astro';
import NetworkCardSquareBig from './NetworkCardSquareBig.astro';
import NetworkCardRectangleSmall from './NetworkCardRectangleSmall.astro';
import NetworkCardCta from './NetworkCardCta.astro';

export const prerender = false;

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const desktopLayout = [
  { type: 'rectangle-big', grid: 'col-[1/4] row-[1/3]' },
  { type: 'rectangle-big', grid: 'col-[4/7] row-[1/3]' },
  { type: 'square-big', grid: 'col-[7/9] row-[1/3]' },
  { type: 'square-small', grid: 'col-[9/10] row-[1/2]' },
  { type: 'rectangle-small', grid: 'col-[10/13] row-[1/2]' },
  { type: 'square-small', grid: 'col-[9/10] row-[2/3]' },
  { type: 'rectangle-small', grid: 'col-[10/13] row-[2/3]' },
  { type: 'rectangle-small', grid: 'col-[1/4] row-[3/4]' },
  { type: 'rectangle-small', grid: 'col-[4/7] row-[3/4]' },
  { type: 'rectangle-small', grid: 'col-[7/10] row-[3/4]' },
  { type: 'rectangle-small', grid: 'col-[10/13] row-[3/4]' },
  { type: 'rectangle-small', grid: 'col-[1/4] row-[4/5]' },
  { type: 'rectangle-small', grid: 'col-[4/7] row-[4/5]' },
  { type: 'square-small', grid: 'col-[7/8] row-[4/5]' },
  { type: 'square-small', grid: 'col-[8/9] row-[4/5]' },
  { type: 'square-small', grid: 'col-[9/10] row-[4/5]' },
  { type: 'square-small', grid: 'col-[10/11] row-[4/5]' },
  { type: 'cta', grid: 'col-[11/13] row-[4/5]' },
] as const;

const mobileLayout = [
  { type: 'square-big', grid: 'col-[1/3] row-[1/3]' },
  { type: 'square-big', grid: 'col-[3/5] row-[1/3]' },
  { type: 'rectangle-small', grid: 'col-[1/3] row-[3/4]' },
  { type: 'rectangle-small', grid: 'col-[3/5] row-[3/4]' },
  { type: 'rectangle-small', grid: 'col-[1/3] row-[4/5]' },
  { type: 'rectangle-small', grid: 'col-[3/5] row-[4/5]' },
  { type: 'rectangle-small', grid: 'col-[1/3] row-[5/6]' },
  { type: 'square-small', grid: 'col-[3/4] row-[5/6]' },
  { type: 'square-small', grid: 'col-[4/5] row-[5/6]' },
  { type: 'square-small', grid: 'col-[1/2] row-[6/7]' },
  { type: 'square-small', grid: 'col-[2/3] row-[6/7]' },
  { type: 'square-small', grid: 'col-[3/4] row-[6/7]' },
  { type: 'square-small', grid: 'col-[4/5] row-[6/7]' },
  { type: 'cta', grid: 'col-[1/5] row-[7/8]' },
] as const;

const cellStyle = ['bg-gray-50', 'border', 'border-lav-border'];

// Read networks from KV (only source of truth)
let searchableNetworks: SearchableNetwork[] = [];

try {
  const KV = Astro.locals.runtime?.env?.KV;
  if (KV) {
    const kvData = await getNetworks(KV);
    if (kvData.length > 0) {
      searchableNetworks = kvData.map((network) => {
        const description = network.description[lang] || network.description.tr || '';
        const logoSrc = `${R2_PUBLIC_URL}/networks/${network.logoKey}`;
        return {
          id: network.id,
          name: network.name,
          symbol: network.symbol,
          description,
          apr: network.apr,
          logoSrc,
          logoWidth: 200,
          logoHeight: 200,
          features: [...network.features],
          searchText: `${network.name} ${network.symbol} ${description}`.toLocaleLowerCase(),
        };
      });
    }
  }
} catch {
  // KV unavailable
}

function createGridItemsFromLayout(
  layout: ReadonlyArray<{ type: CardType; grid: string }>,
  displayClass: string,
): GridItem[] {
  let networkCursor = 0;
  let slotIndex = 0;

  return layout.map(({ type, grid }) => {
    if (type === 'cta') {
      return { type, grid, displayClass };
    }

    const network = networkCursor < searchableNetworks.length
      ? searchableNetworks[networkCursor]
      : undefined;

    networkCursor++;
    return { type, grid, displayClass, slotIndex: slotIndex++, network };
  });
}

function isSearchSlot(item: GridItem): boolean {
  return item.type !== 'cta' && typeof item.slotIndex === 'number';
}

function getGridItemClassList(item: GridItem) {
  return [
    item.grid,
    item.displayClass,
    ...cellStyle,
    'min-h-0',
    'overflow-hidden',
    'rounded-[calc(var(--vw)*6)]',
    'p-[calc(var(--vw)*3)]',
    'font-sans',
    'lg:rounded-[calc(var(--vw)*2)]',
    'lg:p-[calc(var(--vw)*1.4)]',
    {
      '!p-0': item.type === 'cta',
      'network-slot': item.type !== 'cta',
      'aspect-square lg:aspect-auto': item.type === 'square-big',
      'items-center justify-center': item.type === 'square-small',
    },
  ];
}

const desktopItems = createGridItemsFromLayout(desktopLayout, 'hidden lg:flex');
const mobileItems = createGridItemsFromLayout(mobileLayout, 'flex lg:hidden');
const allItems = [...desktopItems, ...mobileItems];
---

<div class={`
  relative
  m-(--section-margin)
  w-[calc(100%-var(--section-margin)*2)]
`}>
  <section
    class={`
      @container
      relative
      isolate
      flex
      flex-col
      gap-8
      overflow-x-clip
      bg-[radial-gradient(ellipse_45%_45%_at_center,#E5E6FF_0%,transparent_100%)]
      py-12
      sm:py-16
      md:py-20
      lg:gap-12
      lg:py-24
    `}
    aria-label={t('networks.ariaLabel')}
    data-networks-component
  >
  <!-- Title section -->
  <div class={`
    flex
    flex-col
    gap-8
    font-sans
    lg:flex-row
    lg:items-center
    lg:justify-between
    lg:gap-16
  `}>
    <h2 class={`
      font-display
      text-5xl
      leading-[0.85]
      font-bold
      text-balance
      text-espresso
      md:text-6xl
      lg:w-[60%]
      lg:text-7xl
    `}>
      {t('networks.title')}
    </h2>

    <div class={`
      flex
      flex-col
      gap-6
      lg:w-[40%]
      lg:items-start
    `}>
      <p class={`
        text-xs
        leading-relaxed
        text-espresso
        sm:text-sm
        md:text-base
      `}>
        {t('networks.description')}
      </p>

      <a
        href="#"
        class={`
          inline-flex
          w-fit
          items-center
          justify-center
          rounded-full
          bg-espresso
          px-5
          py-2
          text-sm
          text-cream
          transition-colors
          hover:bg-espresso/90
        `}
      >
        {t('networks.cta')}
      </a>
    </div>
  </div>

  <div class={`
    flex
    items-center
    gap-2
    font-sans
    lg:gap-3
  `}>
    <div class="relative">
      <input type="radio" name="network-filter" id="network-filter-all"
        value="all" checked class={`
          peer
          sr-only
        `} data-network-filter />
      <label for="network-filter-all"
        class={`
          cursor-pointer
          rounded-full
          border
          border-[#6A4D42]
          bg-transparent
          px-3
          py-1
          text-sm
          text-[#6A4D42]
          transition-colors
          peer-checked:bg-lavender
          lg:px-4
          lg:py-2
        `}>
        all
      </label>
    </div>
    <div class="relative">
      <input type="radio" name="network-filter" id="network-filter-staking"
        value="staking" class={`
          peer
          sr-only
        `} data-network-filter />
      <label for="network-filter-staking"
        class={`
          cursor-pointer
          rounded-full
          border
          border-[#6A4D42]
          bg-transparent
          px-3
          py-1
          text-sm
          text-[#6A4D42]
          transition-colors
          peer-checked:bg-lavender
          lg:px-4
          lg:py-2
        `}>
        staking
      </label>
    </div>
    <div class="relative">
      <input type="radio" name="network-filter" id="network-filter-rpc"
        value="rpc" class={`
          peer
          sr-only
        `} data-network-filter />
      <label for="network-filter-rpc"
        class={`
          cursor-pointer
          rounded-full
          border
          border-[#6A4D42]
          bg-transparent
          px-3
          py-1
          text-sm
          text-[#6A4D42]
          transition-colors
          peer-checked:bg-lavender
          lg:px-4
          lg:py-2
        `}>
        rpc
      </label>
    </div>

    <div class={`
      relative
      ml-auto
      w-full
      lg:w-[calc(var(--vw)*27)]
    `}>
      <img
        src="/img/search.svg"
        alt=""
        class={`
          pointer-events-none
          absolute
          top-1/2
          left-3
          size-3.5
          -translate-y-1/2
          lg:left-3
        `}
        aria-hidden="true"
      />
      <input
        id="networks-search"
        type="search"
        autocomplete="off"
        placeholder={t('networks.search.placeholder')}
        class={`
          w-full
          rounded-full
          border
          border-[#6A4D42]
          bg-gray-50
          py-1
          pr-0
          pl-8
          text-sm
          text-espresso-dark
          transition-colors
          outline-none
          placeholder:text-placeholder
          focus:border-espresso-dark
          lg:py-2
          lg:pr-4
          lg:pl-8
          [&::-webkit-search-cancel-button]:appearance-none
        `}
        data-networks-search-input
      />
    </div>
  </div>

  <!-- Networks Grid -->
  <div class={`
    grid
    grid-cols-4
    grid-rows-[repeat(6,calc(25cqi-var(--vw)*3))_auto]
    gap-[calc(var(--vw)*4)]
    lg:grid-cols-12
    lg:grid-rows-[repeat(4,calc(8.3333cqi-var(--vw)*1.2833))]
    lg:gap-[calc(var(--vw)*1.4)]
  `}>
    {allItems.map((item) => {
      const network = item.network;
      const searchSlot = isSearchSlot(item);
      return (
        <div
          class:list={getGridItemClassList(item)}
          data-network-slot={searchSlot ? '' : undefined}
          data-slot-index={searchSlot ? item.slotIndex : undefined}
        >
          {item.type === 'rectangle-big' && network && (
            <NetworkCardRectangleBig network={network} />
          )}

          {item.type === 'square-big' && network && (
            <NetworkCardSquareBig network={network} />
          )}

          {item.type === 'square-small' && network && (
            <img
              src={network.logoSrc}
              alt={network.name}
              width={network.logoWidth}
              height={network.logoHeight}
              class:list={imgClass['square-small']}
              data-network-logo
            />
          )}

          {item.type === 'rectangle-small' && network && (
            <NetworkCardRectangleSmall network={network} />
          )}

          {item.type === 'cta' && (
            <NetworkCardCta t={t} />
          )}
        </div>
      );
    })}
  </div>
  </section>
</div>

<script define:vars={{ searchableNetworks }}>
  const component = document.querySelector('[data-networks-component]');

  if (!(component instanceof HTMLElement)) return;

  const searchInput = component.querySelector('[data-networks-search-input]');
  const filterRadios = Array.from(
    component.querySelectorAll('input[data-network-filter]'),
  ).filter((el) => el instanceof HTMLInputElement);
  const slotElements = Array.from(component.querySelectorAll('[data-network-slot]')).filter(
    (slot) => slot instanceof HTMLElement,
  );

  if (!(searchInput instanceof HTMLInputElement) || slotElements.length === 0) return;

  const networksData = Array.isArray(searchableNetworks) ? searchableNetworks : [];
  const renderedSlotState = new WeakMap();

  const getActiveFilter = () => {
    const checked = component.querySelector('input[data-network-filter]:checked');
    return checked instanceof HTMLInputElement ? checked.value : 'all';
  };

  const slotBindings = slotElements
    .map((slot) => {
      const slotIndex = Number(slot.getAttribute('data-slot-index'));
      if (!Number.isFinite(slotIndex)) return null;

      return {
        slot,
        slotIndex,
        logos: Array.from(slot.querySelectorAll('[data-network-logo]')).filter((node) => node instanceof HTMLImageElement),
        names: Array.from(slot.querySelectorAll('[data-network-name]')).filter((node) => node instanceof HTMLElement),
        symbols: Array.from(slot.querySelectorAll('[data-network-symbol]')).filter((node) => node instanceof HTMLElement),
        aprValues: Array.from(slot.querySelectorAll('[data-network-apr]')).filter((node) => node instanceof HTMLElement),
        descriptions: Array.from(slot.querySelectorAll('[data-network-description]')).filter((node) => node instanceof HTMLElement),
        featureContainers: Array.from(slot.querySelectorAll('[data-network-features]')).filter((node) => node instanceof HTMLElement),
      };
    })
    .filter((binding) => binding !== null);

  const setEmptySlot = (binding) => {
    binding.slot.classList.add('opacity-0', 'pointer-events-none');
    binding.slot.setAttribute('aria-hidden', 'true');
  };

  const setFilledSlot = (binding, network) => {
    binding.slot.classList.remove('opacity-0', 'pointer-events-none');
    binding.slot.removeAttribute('aria-hidden');

    for (const logoNode of binding.logos) {
      logoNode.src = network.logoSrc;
      logoNode.alt = network.name;
      logoNode.width = network.logoWidth;
      logoNode.height = network.logoHeight;
    }

    for (const nameNode of binding.names) {
      nameNode.textContent = network.name.toLocaleUpperCase('en');
    }

    for (const symbolNode of binding.symbols) {
      symbolNode.textContent = network.symbol.toLocaleUpperCase('en');
    }

    for (const aprNode of binding.aprValues) {
      aprNode.textContent = `APR ${network.apr}%`;
    }

    for (const descriptionNode of binding.descriptions) {
      descriptionNode.textContent = network.description;
    }

    for (const featureContainer of binding.featureContainers) {
      for (const pill of featureContainer.querySelectorAll('[data-feature]')) {
        pill.classList.toggle('hidden', !network.features.includes(pill.dataset.feature));
      }
    }
  };

  const getNetworkForSlot = (matches, slotIndex) => {
    return slotIndex < matches.length ? matches[slotIndex] : undefined;
  };

  const render = () => {
    const query = searchInput.value.trim().toLocaleLowerCase();
    const activeFilter = getActiveFilter();
    let filtered = networksData;

    if (activeFilter !== 'all') {
      filtered = filtered.filter((network) =>
        Array.isArray(network.features) && network.features.includes(activeFilter),
      );
    }

    const matches = query
      ? filtered.filter((network) => network.searchText.includes(query))
      : filtered;

    for (const binding of slotBindings) {
      const network = getNetworkForSlot(matches, binding.slotIndex);
      const nextState = network ? network.id : null;
      const previousState = renderedSlotState.get(binding.slot);

      if (previousState === nextState) continue;

      if (network) setFilledSlot(binding, network);
      else setEmptySlot(binding);

      renderedSlotState.set(binding.slot, nextState);
    }
  };

  for (const radio of filterRadios) {
    radio.addEventListener('change', render);
  }
  searchInput.addEventListener('input', render);
  render();
</script>
